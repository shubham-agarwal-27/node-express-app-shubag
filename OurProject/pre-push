#!/usr/bin/env node 
const port = 3000;
const app = require("express")();
const request = require('request');
const opn = require('open');
const sodium = require('tweetsodium');
const fs = require('fs');
const { v4: uuidv4 } = require('uuid');

const input_keys = ['github_PAT', 'tenant_id', 'workflow', 'subscription', 'resource_group', 'resource'];

var scopeForARM = 'https://management.azure.com//user_impersonation';
var scopeForGraph = 'offline_access%20user.read%20Directory.AccessAsUser.All';
const client_id_graph = '3c2ff05c-d8db-48bf-ac19-9b0d7294e050';
const client_id_arm = '33c31634-d8df-4199-99f6-ae4b3fef50cd';

/**
 * Change the color of text
 * @param  {String}	text 	The text to be colored
 * @param  {String} color 	The color number
 * @return {String}       	The colored text
 */
function textColor(text, color) { 
	return `\x1b[${color}m${text}\x1b[0m`; 
}
/**
 * Pause the execution for some time
 * @param  {Number}	time 	The amount of time (in milliseconds)
 * @return {Promise}		Resolves after a certain time
 */
function waitForTime(time){
	return new Promise(resolve => {
		setTimeout(function(){
			resolve();
		}, time);
	});
}
/**
 * Get the contents of the file that was at the time of installation. This will be used when user messes the file.
 * @return {String}		The content of the file that was at the time of installation
 */
function getFileOriginalContent(){
	var original_content = '';
	for(var input_key of input_keys){
		original_content += input_key + ": \n";
	}
	return original_content;
}
/**
 * Read the file contents
 * @param  {String}	file_name 	The name of the file to be read
 * @return {Promise}			The contents of the given file
 */
function getFileContent(file_name){
	return new Promise(resolve => {
		resolve(fs.readFileSync(file_name, "utf8").split("\n"));
	});
}
/**
 * Check if the file contents have been messed up by the user
 * @param  {String}	file_name 	The name of the file to be checked
 * @return {Promise}			Resolves the boolean value whether the file is messed or not
 */
async function checkFileContentMessed(file_name){
	var file_messed_up = false;
	var user_inputs = await getFileContent(file_name);
	var split_input;
	for(var line_number = 0; line_number < user_inputs.length; line_number++){
		split_input = user_inputs[line_number].replace(/\s+/g, '').split(":");
		if(split_input.length < 2 || split_input[0] !== input_keys[line_number]){
			file_messed_up = true;
			break;
		}
	}
	return new Promise(resolve => {
		resolve(file_messed_up);
	});
}
/**
 * Rewrite the file with some content
 * @param  {String}	file_name 	the name of the file to be rewritten
 * @param  {String} content		The content to be written
 * @return {Promise}			Resolves after the contents have been written
 */
async function rewriteFile(file_name, content){	
	return new Promise(resolve => {
		fs.writeFile(file_name, content, function(err){
			if(err){
				console.log(err);
				exit(1);
			}
			resolve();
		});
	});
}
/**
 * Get all the details pertaining to a user's Github account and their subscription and resource choice.
 * @param  {String} file_inputs 		The input file content used for getting some required field values
 * @return {Promise}					Resolves an object that stored the user's' details
 */
async function getUserDetails(file_inputs){
	var userDetails = {};
	for(var input = 0; input < input_keys.length; input++){
		userDetails[input_keys[input]] = file_inputs[input].replace(/\s+/g, '').split(":")[1];
	}
	return new Promise(function(resolve) {
		const { exec } = require('child_process');
		exec('git config --list', (error, stdout, stderr) => {
			var array_stdout = stdout.split("\n");
			for(var single_info of array_stdout){
				var info_splitted = single_info.split("=");
				if(info_splitted[0] === 'user.name'){
					userDetails['username'] = info_splitted[1];
				}

				if(info_splitted[0] === 'user.email'){
					userDetails['user_email'] = info_splitted[1];
				}

				if(info_splitted[0] === 'remote.origin.url'){
					userDetails['repo_name'] = info_splitted[1].split("https://github.com/")[1].split("/")[1].split(".")[0];
				}
			}
			resolve(userDetails);
		});
  	});
}
/**
 * Open the Authentication URL in default browser
 * @param  {String} scope 			The scopes required by the OAuth app
 * @param  {String} callback 		The redirect URL for the OAuth app
 * @param  {String} client_id 		Client ID of the OAuth app
 * @param  {Object} userDetails 	The object that stored user's information
 * @return {Promise}				resolves once the link is open in browser
 */
async function openSignInLink(scope, callback, client_id, userDetails){
	await opn('https://login.microsoftonline.com/'+userDetails['tenant_id']+'/oauth2/v2.0/authorize?client_id='+client_id+'&response_type=code&redirect_uri='+callback+'&response_mode=query&scope='+scope+'&state=AzureShubhamLogIn');
	return new Promise(resolve => {
		resolve();
	});
}
/**
 * Get the redirect  URL for the OAuth process
 * @param  {String} callback 	The redirect page for the OAuth app
 * @return {Promise}			Resolves after sending the data to the redirect page
 */
function getCallback(callback){
	return new Promise(resolve => {
		app.get(callback, function(req, res){
			code = req.query['code'];
			res.send("You are logged in, now you can go back to your terminal!");
			resolve();
		});
	});
}
/**
 * Get the Access token for an endpoint
 * @param  {String} endpoint 		The endpoint used in the OAuth process.
 * @param  {String} scope 			The scopes required by the OAuth app
 * @param  {String} callback 		The redirect page for the OAuth app
 * @param  {String} client_id 		Client ID of the OAuth app
 * @param  {Object} userDetails 	The object that stored user's information
 * @return {Promise}				resolves after the POST request made to obtain access token
 */
function getAccessToken(endpoint, scope, callback, client_id, userDetails){	
	const options = {
		uri: 'https://login.microsoftonline.com/'+userDetails['tenant_id']+'/oauth2/v2.0/token',
		json: true,
		body: 'client_id='+client_id+'&scope='+scope+'&redirect_uri='+callback+'&code='+code+'&grant_type=authorization_code',
		headers: {
			"Content-Type": "application/x-www-form-urlencoded"
		}
	};
	
	return new Promise(resolve => {
		request.post(options, (err, res, body) => {
			if (err) {
				return console.log(err);
			}
			userDetails[endpoint] = body;
			resolve();
		});	
	});
}
/**
 * Get the Repository public key
 * @param  {String} repo_name 	Repository being worked on
 * @param  {String} username 	GitHub user name of the user
 * @param  {String} PAT_token	GitHub PAT token of the user
 * @return {Promise}			Resolves after the GET request made to obtain the public key for the repository
 */
function getRepoPublicKey(repo_name, username, PAT_token){
	var opts = {
		url: 'https://api.github.com/repos/'+username+'/'+repo_name+'/actions/secrets/public-key',
		headers: {
			'User-Agent': 'request',
			Authorization: `Bearer ${PAT_token}`
		}
	};

  	return new Promise(function(resolve, reject) {
    	request(opts, function(error, response, body){
			resolve(JSON.parse(response['body']));
		});
  	});
}
/**
 * Create a new secret in User's GitHub account
 * @param  {String} secret_name 					The secret name to be created
 * @param  {Object} secret_value 					The value of the secret to be created
 * @param  {Object} userDetails 					The object that stored user's information
 * @return {Promise}								Resolves after the PUT request made to create a new secret
 */
async function CreateNewSecret(secret_name, secret_value, userDetails){
	const username = userDetails['username'];
	const user_email = userDetails['user_email'];
	const repo_name = userDetails['repo_name'];

	const repoPublicKey = await getRepoPublicKey(repo_name, username, userDetails['github_PAT']);
	const key = repoPublicKey['key'];

	const messageBytes = Buffer.from(JSON.stringify(secret_value));
	const keyBytes = Buffer.from(key, 'base64');

	const encryptedBytes = sodium.seal(messageBytes, keyBytes);
	const encrypted = Buffer.from(encryptedBytes).toString('base64');

	const body = {
			message: "Adding secret",
			committer: {
				name: username,
				email: user_email
			},
			encrypted_value: encrypted,
			key_id: repoPublicKey['key_id']
	};
	var opts = {
		url: 'https://api.github.com/repos/'+username+'/'+repo_name+'/actions/secrets/'+secret_name,
		method: 'PUT',
		body: JSON.stringify(body),
		headers: {
			"Content-type": "application/json",
			'User-Agent': 'request',
			Authorization: `Bearer ${userDetails['github_PAT']}`
		}
	}

	return new Promise(resolve => {
		request(opts, function(error, response, body){
            resolve();
        });
	});


}
/**
 * Get all the apps registered in user's tenant
 * @param  {Object} userDetails 	The object that stored user's information
 * @return {Promise}				Resolves after the list of apps have been successfully obtained
 */
function getApplications(userDetails){
	var opts = {
		url: "https://graph.microsoft.com/v1.0/applications",
		headers: {
			Authorization: userDetails['graph_details']['token_type'] + ' ' + userDetails['graph_details']['access_token']
		}
	};
	return new Promise(function(resolve, reject) {
		request(opts, function(error, response, body){
			userDetails['applications'] = JSON.parse(response['body'])['value'];
			resolve();
		});
	});
}
/**
 * Check if there exists an app for the SPN already created by the product in user's tenant
 * @param  {Object} userDetails 	The object that stored user's information
 * @param  {String} app_name 		The name of the app to be checked
 * @return {Boolean}				The boolean value whether the app exists or not
 */
function newAppRequired(userDetails, app_name){
	for(var application of userDetails['applications']){
		if(application['displayName'] === 'AppForSPN'){
			return false;
		}
	}
	return true;
}
/**
 * Create an App in user's tenant that will be used to create an SPN
 * @param  {Object} userDetails 	The object that stored user's information
 * @param  {String} app_name 		The name of the app to be checked
 * @return {Promise}				Resolves after the POST request made to create an app
 */
function createApp(userDetails, app_name){
	const options = {
		url: 'https://graph.microsoft.com/v1.0/applications',
		json: true,
		body: {
			"displayName": app_name
		},
		headers: {
			"Content-Type": "application/json",
			Authorization: userDetails['graph_details']['token_type'] + ' ' + userDetails['graph_details']['access_token']
		}
	};
	return new Promise(resolve => {
		request.post(options, (err, res, body) => {
			if (err) {
				return console.log(err);
			}
			userDetails['new_app_details'] = body;
			resolve();
		});	
	});
}
/**
 * Create a Service Principal
 * @param  {Object} userDetails 	The object that stored user's information
 * @return {Promise}				Resolves after the POST request made to create an SPN
 */
function createServicePrincipal(userDetails){
	const options = {
		url: 'https://graph.microsoft.com/v1.0/serviceprincipals',
		json: true,
		body: {
			"appId": userDetails['new_app_details']['appId']
		},
		headers: {
			"Content-Type": "application/json",
			Authorization: userDetails['graph_details']['token_type'] + ' ' + userDetails['graph_details']['access_token']
		}
	};
	
	return new Promise(resolve => {
		request.post(options, (err, res, body) => {
			if (err) {
				return console.log(err);
			}
			userDetails['new_app_details']['spn_details'] = body;
			resolve();
		});
	});
}
/**
 * Create a password for the new app created
 * @param  {Object} userDetails 	The object that stored user's information
 * @return {Promise}				Resolves after the POST request made to create the password
 */
function addPassword(userDetails){
	const options = {
		url: 'https://graph.microsoft.com/v1.0/applications/'+userDetails['new_app_details']['id']+'/addPassword',
		json: true,
		body: {
			"passwordCredential": {
				"displayName": "PasswordShubham"
			  }
		},
		headers: {
			"Content-Type": "application/json",
			Authorization: userDetails['graph_details']['token_type'] + ' ' + userDetails['graph_details']['access_token']
		}
	};
	
	return new Promise(resolve => {
		request.post(options, (err, res, body) => {
			if (err) {
				return console.log(err);
			}
			userDetails['new_app_details']['password'] = body['secretText'];
			resolve();
		});	
	});
}
/**
 * Add a role assignment to the SPN created
 * @param  {Object} userDetails 	The object that stored user's information
 * @param {String} guid				GUID used as a parameter in the request URL
 * @return {Promise}				Resolves after the PUT request made to add a role assignment
 */
function addRoleAssignment(userDetails, guid){
	
	var subscriptionId = userDetails['subscription'];
	var resourceGroup = userDetails['resource_group'];
	var opts = {
		url: 'https://management.azure.com/subscriptions/'+subscriptionId+'/resourcegroups/'+resourceGroup+'/providers/Microsoft.Authorization/roleAssignments/'+guid+'?api-version=2015-07-01',
		method: 'PUT',
		json: true,
		body: {
			"properties": {
				"roleDefinitionId": "/subscriptions/"+subscriptionId+"/resourcegroups/"+resourceGroup+"/providers/Microsoft.Authorization/roleDefinitions/b24988ac-6180-42a0-ab88-20f7382dd24c",
				"principalId": userDetails['new_app_details']['spn_details']['id'],
				"scope": "/subscriptions/"+subscriptionId+"/resourcegroups/"+resourceGroup
			}
		},
		headers: {
			"Content-type": "application/json",
			'User-Agent': 'request',
			Authorization: userDetails['arm_details']['token_type'] + ' ' + userDetails['arm_details']['access_token']
		}
	};

	return new Promise(resolve => {
		request(opts, function(error, response, body){
			userDetails['new_role_assignment'] = body;
			resolve();
		});
	});
}
/**
 * Authenticate the user's azure account for the Microsoft Graph endpoint
 * @param {Object} userDetails	The object that stored user's information
 */
async function OAuthGraph(userDetails){
	await openSignInLink(scopeForGraph, 'http://localhost:3000/callback', client_id_graph, userDetails);
	await getCallback('/callback');
	await getAccessToken('graph_details', scopeForGraph, 'http://localhost:3000/callback', client_id_graph, userDetails);
}
/**
 * Authenticate the user's azure account for the ARM endpoint
 * @param {Object} userDetails	The object that stored user's information
 */
async function OAuthARM(userDetails){
	await openSignInLink(scopeForARM, 'http://localhost:3000/callbackarm', client_id_arm, userDetails);
	await getCallback('/callbackarm');
	await getAccessToken('arm_details', scopeForARM, 'http://localhost:3000/callbackarm', client_id_arm, userDetails);
}
/**
 * Get all the resource groups in user's subscription
 * @param  {String} token_type 		The type of access token being used
 * @param  {String} access_token	The token value being used for authorization
 * @param  {String} subscriptionId 	Subscription ID of the chosen subscription
 * @return {Promise}				Resolves the array that contains all the resource group objects
 */
function getResourceGroups(token_type, access_token, subscriptionId){
	var opts = {
		url: 'https://management.azure.com/subscriptions/'+subscriptionId+'/resourcegroups?api-version=2019-10-01',
		headers: {
			Authorization: token_type + ' ' + access_token
		}
	};
	return new Promise(function(resolve, reject) {
		request(opts, function(error, response, body){
			resolve(JSON.parse(response['body'])['value']);
		});
	});
}
/**
 * Get all the resources in user's resource group
 * @param  {String} token_type 		The type of access token being used
 * @param  {String} access_token	The token value being used for authorization
 * @param  {String} subscriptionId 	Subscription ID of the chosen subscription
 * @param  {String} resourceGroup 	Resource Group name of the chosen resource group
 * @return {Promise}				Resolves the array that contains all the resource objects
 */
function getResources(token_type, access_token, subscriptionId, resourceGroup){
	var opts = {
		url: "https://management.azure.com/subscriptions/"+subscriptionId+"/resourceGroups/"+resourceGroup+"/resources?$filter=resourceType eq 'Microsoft.Web/sites'&api-version=2019-10-01",
		headers: {
			Authorization: token_type + ' ' + access_token
		}
	};
	return new Promise(function(resolve, reject) {
		request(opts, function(error, response, body){
			resolve(JSON.parse(response['body'])['value']);
		});
	});
}
/**
 * Check is resurce or resource group is present or not
 * @param  {String} to_be_checked 	the value is either resource_groups or resources
 * @param  {String} name			the value is either resource_group or resource
 * @param  {Object} userDetails 	The object that stored user's information
 * @return {Boolean}				Returns a boolean whether the resource or resource_group exists or not in user's tenant
 */
function checkIfExists(to_be_checked, name, userDetails){
	for(var data of userDetails[to_be_checked]){
		if(data['name'] === userDetails[name])
			return true;
	}
	return false;
}
/**
 * Create a Resource Group in user's Tenant
 * @param  {Object} userDetails 	The object that stored user's information
 * @return {Promise}				Resolves after the Resource Group has been created
 */
function createResourceGroup(userDetails){
	var subscriptionId = userDetails['subscription'];
	var resource_group = userDetails['resource_group'];
	var token_type = userDetails['arm_details']['token_type'];
	var access_token = userDetails['arm_details']['access_token'];
	var opts = {
		url: 'https://management.azure.com/subscriptions/'+subscriptionId+'/resourcegroups/'+resource_group+'?api-version=2019-10-01',
		method: 'PUT',
		json: true,
		body: {
			'location': 'eastus'
		},
		headers: {
			"Content-type": "application/json",
			Authorization: `${token_type} ${access_token}`
		}
	}
	return new Promise(resolve => {
		request(opts, function(error, response, body){
			resolve();
		});
	});
}
/**
 * Create a Resource in user's Tenant
 * @param  {Object} userDetails 	The object that stored user's information
 * @return {Promise}				Resolves after the Resource has been created
 */
function createResource(userDetails){
	var subscriptionId = userDetails['subscription'];
	var resource_group = userDetails['resource_group'];
	var token_type = userDetails['arm_details']['token_type'];
	var access_token = userDetails['arm_details']['access_token'];
	var resource = userDetails['resource'];
	var opts = {
		url: 'https://management.azure.com/subscriptions/'+subscriptionId+'/resourcegroups/'+resource_group+'/providers/Microsoft.Web/sites/'+resource+'?api-version=2019-08-01',
		method: 'PUT',
		json: true,
		body: {
			"location": "East US",
			"type": "Microsoft.Web/sites",
			"properties" : {}
		},
		headers: {
			"Content-type": "application/json",
			Authorization: `${token_type} ${access_token}`
		}
	};
	return new Promise(resolve => {
		request(opts, function(error, response, body){
			// console.log(body);
			resolve();
		});
	});
}

async function main(){
	var original_content = getFileOriginalContent();
	var file_messed = await checkFileContentMessed('give_inputs.txt');
	if(file_messed){
		await writeFile('give_inputs.txt', original_content);
		console.log("You have messed up the file. Please follow the format of giving inputs PROPERLY. Exitting...");
	}
	else{
		app.listen(port, function () {
			console.log("Server Has Started!");
		});
		var guid = uuidv4();
		var file_inputs = await getFileContent('give_inputs.txt');
		var userDetails = await getUserDetails(file_inputs);
		await OAuthGraph(userDetails);
		await OAuthARM(userDetails);
		await waitForTime(1000);
		userDetails['resource_groups'] = await getResourceGroups(userDetails['arm_details']['token_type'], userDetails['arm_details']['access_token'], userDetails['subscription']);
		if(!checkIfExists('resource_groups', 'resource_group', userDetails)){
			console.log("Creating a new Resource Group: " + userDetails['resource_group']);
			await createResourceGroup(userDetails);
		}
		userDetails['resources'] = await getResources(userDetails['arm_details']['token_type'], userDetails['arm_details']['access_token'], userDetails['subscription'], userDetails['resource_group']);
		if(!checkIfExists('resources', 'resource', userDetails)){
			console.log("Creating a new Resource: " + userDetails['resource']);
			await createResource(userDetails);
		}
		await getApplications(userDetails);
		if(newAppRequired(userDetails, 'AppForSPN')){
			await createApp(userDetails, 'AppForSPN');
			await createServicePrincipal(userDetails);
			await addPassword(userDetails);
			await waitForTime(3000);
			var secret_value = {
				"clientId": userDetails['new_app_details']['spn_details']['appId'],
				"clientSecret": userDetails['new_app_details']['password'],
				"subscriptionId": userDetails['subscription'],
				"tenantId": userDetails['tenant_id'],
				"activeDirectoryEndpointUrl": "https://login.microsoftonline.com",
				"resourceManagementEndpointUrl": "https://management.azure.com"
			}
			await CreateNewSecret('AZURE_CREDENTIALS', secret_value, userDetails);
			await addRoleAssignment(userDetails, guid);
		}
		
		// console.log(userDetails['graph_details']);
		// console.log(userDetails['arm_details']);
		console.log();
		console.log('***************************************************************************************************************************************************************');
		console.log();
		console.log(`You can have a look at the workflow runs using this link:\n\n${textColor('https://github.com/'+userDetails['username']+'/'+userDetails['repo_name']+'/actions', 95)}`);
		console.log('                                       Or                                                                          ');
		console.log('IF A WORKFLOW CREATED BY THIS PACKAGE IS BEING TRIGGERED THEN, You can run this command on your terminal to open the link in browser :'+ textColor(' node open_workflow_run', 95));
		console.log();
		console.log('***************************************************************************************************************************************************************');
		console.log();
		setTimeout(process.exit(0), 200);
	}
};

main();