#!/usr/bin/env node 

const fs = require('fs');
const { exec } = require('child_process');
const { exit } = require('process');
const Mustache = require('mustache');

const input_keys = ['github_PAT', 'tenant_id', 'workflow', 'subscription', 'resource_group', 'resource'];

/**
 * Get the contents of the file that was at the time of installation. This will be used when user messes the file.
 * @return {String}		The content of the file that was at the time of installation
 */
function getFileOriginalContent(){
	var original_content = '';
	for(var input_key of input_keys){
		original_content += input_key + ": \n";
	}
	return original_content;
}
/**
 * Pause the execution for some time
 * @param  {Number}	time 	The amount of time (in milliseconds)
 * @return {Promise}		Resolves after a certain time
 */
function waitForTime(time){
	return new Promise(resolve => {
		setTimeout(function(){
			resolve();
		}, time);
	});
}
/**
 * Read the file contents
 * @param  {String}	file_name 	The name of the file to be read
 * @return {Promise}			The array of contents of the given file
 */
function getFileContent(file_name){
	return new Promise(resolve => {
		resolve(fs.readFileSync(file_name, "utf8").split("\n"));
	});
}
/**
 * Check if the file contents have been messed up by the user
 * @param  {String}	file_name 	The name of the file to be checked
 * @return {Promise}			Resolves the boolean value whether the file is messed or not
 */
async function checkFileContentMessed(file_name){	
	var file_messed_up = false;
	var user_inputs = await getFileContent(file_name);
	var split_input;
	for(var line_number = 0; line_number < user_inputs.length; line_number++){
		split_input = user_inputs[line_number].replace(/\s+/g, '').split(":");
		if(split_input.length < 2 || split_input[0] !== input_keys[line_number]){
			file_messed_up = true;
			break;
		}
	}
	return new Promise(resolve => {
		resolve(file_messed_up);
	});
}
/**
 * Rewrite the file with some content
 * @param  {String}	file_name 	the name of the file to be rewritten
 * @param  {String} content		The content to be written
 * @return {Promise}			Resolves after the contents have been written
 */
async function writeFile(file_name, content){	
	return new Promise(resolve => {
		fs.writeFile(file_name, content, function(err){
			if(err){
				console.log(err);
				exit(1);
			}
			resolve();
		});
	});
}
/**
 * Get the Path to the repository
 * @return {Promise}	Resolves the path to the repository
 */
function getRepoPath(){
	return new Promise(resolve => {
		var repo_path = __dirname.split("/").pop().split('\\');
		var temp_path = repo_path.splice(-2,2);
		repo_path = repo_path.join('\\');
		resolve(repo_path);
	});
}
/**
 * Get all the files in the repo
 * @param  {String} repo_path 	The path to the repository
 * @return {Promise}			Resolves an array of files in the repository
 */
function getAllFiles(repo_path){
	return new Promise(resolve => {
		fs.readdir(repo_path, (err, files) => {
			resolve(files);
		});
	});
}
/**
 * Check if it is a DotNetCore repo
 * @param  {Array} files 	The array of files in repository
 * @return {Promise}		Resolves a boolean value whether it is a DotNetCore Repo or not
 */
function isDotnetCoreRepo(files){    
	return new Promise(resolve => {
		resolve(
			files.some((file) => {
			return file.toLowerCase().endsWith("sln") || file.toLowerCase().endsWith("csproj") || file.toLowerCase().endsWith("fsproj");
		}));
	});
}
/**
 * Check if it is a Node repo
 * @param  {Array} files 	The array of files in repository
 * @return {Promise}		Resolves a boolean value whether it is a Node Repo or not
 */
function isNodeRepo(files){
    var nodeFilesRegex = '\\.ts$|\\.js$|package\\.json$|node_modules';
	return new Promise(resolve => {
		resolve(
			files.some((file) => {
				var result = new RegExp(nodeFilesRegex).test(file.toLowerCase());
				return result;
		}));
	});
}
/**
 * Check if it is a Pyton repo
 * @param  {Array} files 	The array of files in repository
 * @return {Promise}		Resolves a boolean value whether it is a Python Repo or not
 */
function isPythonRepo(files){
    var pythonRegex = '.py$';
	return new Promise(resolve => {
		resolve(
			files.some((file) => {
			var result = new RegExp(pythonRegex).test(file.toLowerCase());
			return result;
		}));
	}); 
}
/**
 * Analyze the repo to get the language
 * @param  {Array} files 	The array of files in repository
 * @return {Promise}		Resolves the language for the Repo
 */
async function getRepoAnalysis(files){
	var repo_language;
	var isDotnetCore = await isDotnetCoreRepo(files);
	var isNode = await isNodeRepo(files);
	var isPython = await isPythonRepo(files);
	return new Promise(resolve => {
		if(isDotnetCore){
			repo_language = 'dotnet';
		}
		if(isNode){
			repo_language = 'node';
		}
		if(isPython){
			repo_language = 'python';
		}
		resolve(repo_language);
	});
}
/**
 * Check if there exists a workflow that would get triggered on a push
 * @return {Promise}	Resolves a binary value indicating whether there exists such a workflow or not
 */
function getPushTriggeredWorkflowExistStatus() {
	return new Promise(resolve => {
		exec('ls ".github/workflows', (error, stdout, stderr) => {
			var file_names = stdout.split("\n");
			var workflow_triggers_on_push = 0;
			for(var file_name of file_names){
				if(file_name.length === 0)
					continue;
				var file_content = fs.readFileSync('.github/workflows/'+file_name, "utf8").split("\n");

				for(var line_number = 0; line_number < file_content.length; line_number++){
					if(file_content[line_number].startsWith('on:', 0)){
						var findingPushLineNumber = line_number;
						while(findingPushLineNumber < file_content.length && !file_content[findingPushLineNumber].startsWith("  push:", 0)){
							findingPushLineNumber++;
						}
						if(findingPushLineNumber !== file_content.length){
							workflow_triggers_on_push = 1;
						}
						break;
					}
				}
				if(workflow_triggers_on_push == 1)
					break;
			}
			resolve(workflow_triggers_on_push);
		});
	});
}
/**
 * Populate the variables in the workflow template with corresponding values
 * @param  {String} workflow_file	The template workflow file to be used
 * @param  {String} resource_name	The name of the resource to deploy the app
 * @return {String}  				The text of the workflow file with the variables replaced with required content
 */
function getWorkflowText(workflow_file, resource_name){
	var template = fs.readFileSync("templates/node/workflow.yml").toString();
	var data = {
		"resource_name": "testnodeappshubham"
	};
	template = template.split("\n");
	for(var line_number = 0; line_number < template.length; line_number++){
		var line = template[line_number];
		if(line.includes('{{{')){
			var current_string = '';
			for(var char_number = 0; char_number < template[line_number].length; char_number++){
				if(line[char_number] === '{'){
					break;
				}
				current_string += line[char_number];
			}
			current_string += resource_name
			template[line_number] = current_string;
			break;
		}
	}
	return template.join("\n");
}
/**
 * Create a new Workflow
 * @param  {String} repo_analysis_result	Language used in the repo
 * @param  {String} file_inputs 			The input file content used for getting some required field values
 */
async function createNewWorkflow(repo_analysis_result, file_inputs){
	var workflow_triggers_on_push = await getPushTriggeredWorkflowExistStatus();
	if(workflow_triggers_on_push){
		console.log('--------------------------------------------------------------------------------------------');
		console.log();
		console.log('Another Workflow exists that will be triggered on push.. Therefore not creating new workflow..');
		console.log();
		console.log('---------------------------------------------------------------------------------------------');
		console.log();
	}
	else{
		var workflow = file_inputs[2].replace(/\s+/g, '').split(":");
		var resource_name = file_inputs[5].replace(/\s+/g, '').split(":")[1];
		console.log("Workflow needs to be created.. Please wait a moment.");
		var workflow_file = 'templates/'+repo_analysis_result+'/'+workflow;
		console.log("New " + workflow + " file created...");
		console.log();
		var workflow_text = getWorkflowText(workflow_file, resource_name);
		exec('mkdir ".github/workflows"', async(error, stdout, stderr) => {
			await writeFile('.github/workflows/workflow.yml', workflow_text);
			exec('git add ".github"', (error, stdout, stderr) => {
				console.log(stdout);
			});
		});
	}
}

async function main(){
	var original_content = getFileOriginalContent();
	var file_messed = await checkFileContentMessed('give_inputs.txt');
	if(file_messed){
		await writeFile('give_inputs.txt', original_content);
		console.log("You have messed up the file. Please follow the format of giving inputs PROPERLY. Exitting...");
	}
	else{
		var file_inputs = await getFileContent('give_inputs.txt');
		var repo_path = await getRepoPath();
		var repo_files = await getAllFiles(repo_path);
		var repo_analysis_result = await getRepoAnalysis(repo_files);
		createNewWorkflow(repo_analysis_result, file_inputs);
	}
};
main();